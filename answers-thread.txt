1.uthread:
	在thread结构体中声明变量，以保存线程context
	thread_switch():照抄swtch
	thread_schedule():根据提示，调用thread_switch()
	thread_create():ra改为指向func的入口地址
					sp初始化在栈顶

2.ph:
	假设线程a和b同时进行put操作，他们的key映射到同一个桶中，也就是他们准备对同一个链表进行操作
	线程a将该链表的表头结点table[i]设为自己的next，下一步应该将自己更新为table[i]
	在更新之前，线程b也将自己的next设为原表头，此时新的表头应该为entry-a，但b以为是原表头
	b将自己更新为table[i]，覆盖了进程a的操作，entry-a丢失
	而以上过程可能交替发生，因此都会丢失

3.barrier:
	要做的只有barrier()函数。
	首先，获取bstate的锁以保证对全局变量操作的原子性，先给nthread++
	if里是除了最后一个的其他线程，执行：cond_wait
	else里是最后一个线程，它：
		重置nthread，以供下一轮使用；
		round++，以示本轮结束
		broadcast